<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hibo â€” Cinematic + Modular Effects</title>

  <!-- Tailwind (optional) and Poppins -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet" />

  <style>
    /* Base / original look preserved */
    :root { --bg: #000; --accent: #FFD700; }
    html,body { height:100%; margin:0; background:var(--bg); font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#fff; }
    /* container that will be pinned */
    #pin-container { width:100%; height:100vh; position:relative; overflow:hidden; }

    /* image layer (full-screen) */
    .layer {
      position:absolute; inset:0;
      background-size:cover; background-position:center;
      filter: brightness(0.82);
      opacity:0;
      transform-origin:center center;
      will-change: transform, opacity, background-position;
    }

    /* optional dark overlay on top of image for readability (per scene) */
    .dark-overlay {
      position:absolute; inset:0; background:rgba(0,0,0,0.32); opacity:0; pointer-events:none;
    }

    .text-container {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  transform-style: preserve-3d;
  backface-visibility: hidden;
  /* Optional: subtle text stroke to improve crispness */
  /* -webkit-text-stroke: 0.5px rgba(0,0,0,0.1); */
}


    /* text (keeps original styling) */
    .text-container {
      position:absolute;
      z-index: 60;
      font-weight:700;
      font-size: clamp(2rem, 5vw, 4rem);
      text-align:center;
      color:white;
      text-shadow: 0 4px 15px rgba(0,0,0,0.7);
      opacity:0;
      pointer-events:none;
      transform-origin:center center;
      will-change: transform, opacity;
    }
    .text-container .char { display:inline-block; }

    /* subtitle style */
    .subtitle {
      position:absolute;
      z-index: 60;
      bottom:8%;
      left:50%;
      transform: translateX(-50%);
      font-size: clamp(1rem, 2vw, 1.4rem);
      background: rgba(0,0,0,0.45);
      padding: .35rem .8rem;
      border-radius: .35rem;
      opacity:0;
      text-shadow: 0 2px 6px rgba(0,0,0,0.8);
      pointer-events:none;
      white-space: nowrap;
    }

    /* cinematic overlays */
    .film-grain {
      position:fixed; inset:0; z-index:90;
      pointer-events:none;
      background-image: url('https://www.transparenttextures.com/patterns/noise.png');
      opacity: 0.12;
    }
    .vignette {
      position:fixed; inset:0; z-index:89;
      pointer-events:none;
      background: radial-gradient(circle, rgba(0,0,0,0) 65%, rgba(0,0,0,0.6) 100%);
    }

    /* fade-to-black overlay used between scenes */
    #fade-overlay { position:fixed; inset:0; background:#000; z-index:95; pointer-events:none; opacity:0; }

    /* scroll indicator */
    #scroll-indicator { position:absolute; bottom:22px; left:50%; transform:translateX(-50%); z-index:80; cursor:pointer; opacity:.95; }
    #scroll-indicator svg { width:36px; height:36px; animation: bounce 1.4s infinite; color:#fff; }
    @keyframes bounce { 0%,100%{ transform: translateY(0) } 50%{ transform: translateY(-8px) } }

    /* CTA styles preserved from original refactor */
    #cta-section {
      position:relative;
      width:100%;
      height:100vh;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      background: linear-gradient(135deg, #0F0F23, #1A1A2E, #16213E);
      z-index:10;
    }
    #cta-button { padding:1rem 2rem; border-radius:40px; font-weight:700; background:var(--accent); color:#000; text-decoration:none; }
    /* confetti canvas placed on top of CTA */
    #confetti-canvas { position:absolute; inset:0; z-index:9999; pointer-events:none; }
  </style>
</head>
<body>

  <!-- cinematic overlays -->
  <div class="film-grain"></div>
  <div class="vignette"></div>
  <div id="fade-overlay"></div>

  <!-- pinned storytelling container -->
  <div id="pin-container">
    <div id="scroll-indicator" title="Scroll">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 9l-7 7-7-7"/></svg>
    </div>
    <!-- layers and text will be injected here by script -->
  </div>

  <!-- CTA (final section) -->
  <section id="cta-section">
    <h2 style="font-size:clamp(2.5rem,6vw,5rem); margin-bottom:1rem; text-align:center; font-weight:700;">Start Your Journey</h2>
    <p style="max-width:680px; text-align:center; margin-bottom:1.5rem;">Transform your life through the power of small, consistent habits. Every expert was once a beginner.</p>
    <a id="cta-button" href="#">Begin Your Transformation ðŸš€</a>
    <canvas id="confetti-canvas"></canvas>
  </section>

  <!-- GSAP & ScrollTrigger -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
  <!-- confetti lib -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <script>
    gsap.registerPlugin(ScrollTrigger);

    ////////////////////////////////
    // === EFFECT LIBRARIES ===
    // Separate dictionaries: textEffects and imageEffects
    ////////////////////////////////
    const textEffects = {
      // char-by-char slide up (original style)
      slideUp: (chars, container, tlRef) => {
        return gsap.from(chars, { y: 60, opacity: 0, stagger: 0.03, ease: 'power2.out' });
      },

      // scale in each char
      scaleIn: (chars, container, tlRef) => {
        return gsap.from(chars, { scale: 0.5, opacity: 0, stagger: 0.04, ease: 'back.out(1.7)' });
      },

      // simple fade-in
      fadeIn: (chars, container, tlRef) => {
        return gsap.from(chars, { opacity: 0, stagger: 0.05, ease: 'power1.inOut' });
      },

      // subtitle-style container animation (not char-by-char)
      subtitle: (chars, container, tlRef) => {
        return gsap.fromTo(container, { y: 20, opacity: 0 }, { y:0, opacity:1, duration: 0.8, ease: 'power2.out' });
      },

      // the "triple bounce" style for text (sharp jumps) â€” keeps original centering
      tripleBounceText: (chars, container, tlRef, opts = {}) => {
        const duration = opts.duration || 3;
        // ensure container centered
        gsap.set(container, { xPercent: -50, yPercent: -50, top: "50%", left: "50%" });
        const tl = gsap.timeline();
        tl.set(container, { opacity: 1, scale: 1 }, 0);
        // three sudden jumps (using immediate sets so jumps feel instantaneous)
        tl.to({}, { duration: duration/3 });
        tl.set(container, { scale: 2.2 }, ">0");
        tl.to({}, { duration: duration/3 });
        tl.set(container, { scale: 3.4 }, ">0");
        tl.to({}, { duration: duration/3 });
        tl.set(container, { scale: 4.5 }, ">0");
        return tl;
      }
    };

    const imageEffects = {
      // fade image in
      fadeIn: (layer, tlRef, opts = {}) => {
        return gsap.fromTo(layer, { opacity: 0 }, { opacity: 1, duration: opts.duration || 1, ease: 'power1.out' });
      },

      // ken burns style gentle zoom (opt-in)
      kenBurns: (layer, tlRef, opts = {}) => {
        return gsap.to(layer, { scale: opts.toScale || 1.06, xPercent: (opts.xPercent||-1), duration: opts.duration || 6, ease: 'power1.inOut' });
      },

      // triple jump effect for images (opt-in)
      tripleJumpImage: (layer, tlRef, opts = {}) => {
        const duration = opts.duration || 3;
        const tl = gsap.timeline();
        tl.set(layer, { scale: 1 }, 0);
        tl.to({}, { duration: duration/3 });
        tl.set(layer, { scale: 1.2 }, ">0");
        tl.to({}, { duration: duration/3 });
        tl.set(layer, { scale: 1.4 }, ">0");
        tl.to({}, { duration: duration/3 });
        tl.set(layer, { scale: 1.6 }, ">0");
        return tl;
      },

      // small pan left-to-right (background-position)
      slowPan: (layer, tlRef, opts={}) => {
        // uses backgroundPositionX to create a pan effect
        const start = opts.start || '45%';
        const end = opts.end || '55%';
        gsap.set(layer, { backgroundPositionX: start });
        return gsap.to(layer, { backgroundPositionX: end, duration: opts.duration || 6, ease: 'none' });
      }
    };

    ////////////////////////////////
    // === STORY CONFIG ===
    // Each scene: image, text, subtitle (optional), and arrays of effect names
    // Keep this near-original â€” only specify effects by name (strings)
    ////////////////////////////////
    const storyConfig = {
      scenes: [
        {
          text: "This is Hibo.",
          subtitle: "The beginning of something great",
          image: "https://images.unsplash.com/photo-1540553016722-983e48a2cd10?w=1920&h=1080&fit=crop",
          textEffects: ["slideUp"],
          imageEffects: ["fadeIn"],
          overlayOpacity: 0.30, // per-scene overlay (helps readability)
          position: { top: "50%", left: "50%" }
        },
        {
          text: "A burst of motivation.",
          subtitle: "Energy like never before",
          image: "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=1920&h=1080&fit=crop",
          textEffects: ["scaleIn"],
          imageEffects: ["fadeIn", "kenBurns"], // kenBurns only because explicitly chosen
          overlayOpacity: 0.28,
          position: { top: "20%", left: "50%" }
        },
        {
          text: "He worked harder and harder.",
          subtitle: "Day after day",
          image: "https://images.unsplash.com/photo-1534438327276-14e5300c3a48?w=1920&h=1080&fit=crop",
          textEffects: ["fadeIn", "subtitle"],
          imageEffects: ["fadeIn"],
          overlayOpacity: 0.40,
          position: { top: "80%", left: "50%" }
        },
        // intense / "again" scene â€” keeps the triple-bounce for text, image triple jump only if explicitly included
        {
          text: "Again",
          subtitle: "Relentless effort",
          image: "https://images.unsplash.com/photo-1568602471122-7832951cc4c5?w=1920&h=1080&fit=crop",
          textEffects: ["tripleBounceText"],
          imageEffects: ["tripleJumpImage"], // opt-in triple image jump to match text intensity
          overlayOpacity: 0.45,
          position: { top: "50%", left: "50%" }
        },
        {
          text: "He found the secret.",
          subtitle: "Persistence",
          image: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1920&h=1080&fit=crop",
          textEffects: ["scaleIn"],
          imageEffects: ["fadeIn", "slowPan"],
          overlayOpacity: 0.28,
          position: { top: "30%", left: "80%" }
        },
        {
          text: "Start your journey.",
          subtitle: "Yours begins now",
          image: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1920&h=1080&fit=crop",
          textEffects: ["slideUp", "subtitle"],
          imageEffects: ["fadeIn"],
          overlayOpacity: 0.30,
          position: { top: "60%", left: "25%" }
        }
      ]
    };

    ////////////////////////////////
    // === BUILD DOM ===
    // We keep the original DOM structure: layers + textContainers rendered into #pin-container
    ////////////////////////////////
    const pinContainer = document.getElementById('pin-container');
    const fadeOverlay = document.getElementById('fade-overlay');
    const layers = [];
    const overlays = [];
    const textContainers = [];
    const subtitleContainers = [];

    storyConfig.scenes.forEach((scene, i) => {
      // layer
      const layer = document.createElement('div');
      layer.className = 'layer';
      layer.style.backgroundImage = `url('${scene.image}')`;
      layer.style.backgroundPosition = '50% 50%';
      pinContainer.appendChild(layer);
      layers.push(layer);

      // overlay (darkening layer for readability)
      const overlay = document.createElement('div');
      overlay.className = 'dark-overlay';
      overlay.style.opacity = 0; // controlled by timeline
      pinContainer.appendChild(overlay);
      overlays.push(overlay);

      // text container (split into chars like original)
      const textWrap = document.createElement('div');
      textWrap.className = 'text-container';
      // position
      textWrap.style.top = (scene.position && scene.position.top) || "50%";
      textWrap.style.left = (scene.position && scene.position.left) || "50%";
      textWrap.style.transform = "translate(-50%, -50%)";
      // char split
      textWrap.innerHTML = scene.text.split("").map(c => `<span class="char">${c === " " ? "&nbsp;" : c}</span>`).join("");
      pinContainer.appendChild(textWrap);
      textContainers.push(textWrap);

      // subtitle
      const subtitle = document.createElement('div');
      subtitle.className = 'subtitle';
      subtitle.textContent = scene.subtitle || "";
      pinContainer.appendChild(subtitle);
      subtitleContainers.push(subtitle);
    });

    ////////////////////////////////
    // === MASTER TIMELINE ===
    // We'll do: fadeOverlay -> show layer -> apply image effects -> apply text effects -> hold -> fadeOverlay -> next
    ////////////////////////////////
    const masterTl = gsap.timeline({
      scrollTrigger: {
        trigger: pinContainer,
        pin: true,
        scrub: 1,
        end: "+=12000"
      }
    });

    // helper to apply text effects by name (returns tween or timeline)
    function applyTextEffectByName(name, chars, container) {
      if (!name) return null;
      const fn = textEffects[name];
      if (!fn) { console.warn("Missing text effect:", name); return null; }
      // tripleBounceText returns a timeline which expects container-level control
      return fn(chars, container, masterTl);
    }

    // helper to apply image effects by name
    function applyImageEffectByName(name, layer) {
      if (!name) return null;
      const fn = imageEffects[name];
      if (!fn) { console.warn("Missing image effect:", name); return null; }
      return fn(layer, masterTl);
    }

    // Build the sequence
    storyConfig.scenes.forEach((scene, index) => {
      const layer = layers[index];
      const overlay = overlays[index];
      const textWrap = textContainers[index];
      const subtitleEl = subtitleContainers[index];
      const chars = textWrap.querySelectorAll('.char');

      // 1) fade to black before switching (cinematic cut)
      masterTl.to(fadeOverlay, { opacity: 1, duration: 0.35 });

      // 2) ensure layer visible & reset transforms
      masterTl.set(layer, { opacity: 1, scale: 1, clearProps: "transform" });
      masterTl.set(overlay, { opacity: scene.overlayOpacity || 0.32 });

      // 3) reveal by fading overlay out
      masterTl.to(fadeOverlay, { opacity: 0, duration: 0.35 });

      // 4) image effects (parallel)
      if (Array.isArray(scene.imageEffects)) {
        scene.imageEffects.forEach(effectName => {
          const imgAnim = applyImageEffectByName(effectName, layer);
          if (imgAnim) masterTl.add(imgAnim, "<"); // run image effects in parallel with the reveal
        });
      } else {
        // default gentle scale (small) to keep original feel if none specified
        masterTl.to(layer, { scale: 1.02, duration: 2, ease: 'power1.out' }, "<");
      }

      // 5) text reveal: either char effects or container-level (subtitle)
      // we add text opacity first so the container becomes visible and effects behave correctly
      masterTl.to(textWrap, { opacity: 1, duration: 0.08 }, "<");

      if (Array.isArray(scene.textEffects)) {
        scene.textEffects.forEach(effectName => {
          const txtAnim = applyTextEffectByName(effectName, chars, textWrap);
          if (txtAnim) masterTl.add(txtAnim, "<");
        });
      } else {
        // fallback
        masterTl.add(textEffects.fadeIn(chars, textWrap, masterTl), "<");
      }

      // show subtitle (if any) slightly after main text
      if (subtitleEl && subtitleEl.textContent.trim()) {
        masterTl.to(subtitleEl, { opacity: 1, duration: 0.45 }, "<+0.2");
      }

      // hold for readability
      masterTl.to({}, { duration: 0.9 });

      // fade out layer/text/overlay before next scene
      if (index < storyConfig.scenes.length - 1) {
        masterTl.to(subtitleEl, { opacity: 0, duration: 0.35 }, "<");
        masterTl.to(textWrap, { opacity: 0, duration: 0.6 }, "<");
        masterTl.to([layer, overlay], { opacity: 0, duration: 0.8 }, "<+0.1");
        masterTl.set([layer, overlay, textWrap, subtitleEl], { clearProps: "transform,opacity" });
      }
    });

    // ensure clear at end so CTA appears cleanly
    masterTl.to(fadeOverlay, { opacity: 0, duration: 0.2 });

    ////////////////////////////////
    // CTA timeline + confetti
    ////////////////////////////////
    const cta = document.getElementById('cta-section');
    const ctaTl = gsap.timeline({
      scrollTrigger: {
        trigger: cta, start: "top 80%", toggleActions: "play none none none"
      }
    });

    ctaTl.from(cta, { opacity: 0, scale: 0.95, duration: 0.9 });
    ctaTl.call(() => {
      if (!cta.dataset.confettiLaunched) {
        fireConfettiBurst(); // confetti live
        cta.dataset.confettiLaunched = "true";
      }
    }, null, ">-0.3");

    // confetti (canvas-confetti)
    function fireConfettiBurst() {
      const duration = 2 * 1000;
      const end = Date.now() + duration;
      (function frame() {
        confetti({
          particleCount: 5,
          angle: 60,
          spread: 55,
          origin: { x: 0.1, y: 0.2 }
        });
        confetti({
          particleCount: 5,
          angle: 120,
          spread: 55,
          origin: { x: 0.9, y: 0.2 }
        });
        if (Date.now() < end) requestAnimationFrame(frame);
      })();
    }

    ////////////////////////////////
    // Scroll indicator: hide after first scroll or click
    ////////////////////////////////
    const scrollIndicator = document.getElementById('scroll-indicator');
    function hideScrollIndicator() {
      gsap.to(scrollIndicator, { opacity: 0, y: 16, duration: 0.6, pointerEvents: 'none' });
      window.removeEventListener('scroll', onFirstScroll);
    }
    function onFirstScroll() { hideScrollIndicator(); }
    window.addEventListener('scroll', onFirstScroll, { once: true });
    scrollIndicator.addEventListener('click', () => {
      window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
      hideScrollIndicator();
    });

    // expose for dev debugging
    window.__HIBO = { textEffects, imageEffects, storyConfig, masterTl };

  </script>
</body>
</html>
