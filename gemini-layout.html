<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Hibo â€” Cinematic + Modular Effects</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Poppins Font -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet" />
    <!-- Tone.js for Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <style>
        /* Base / original look preserved */
        :root { --bg: #000; --accent: #FFD700; }
        html, body { height:100%; margin:0; background:var(--bg); font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#fff; }
        /* container that will be pinned */
        #pin-container { width:100%; height:100vh; position:relative; overflow:hidden; }

        /* image layer (full-screen) */
        .layer {
            position:absolute; inset:0;
            background-size:cover; background-position:center;
            filter: brightness(0.82);
            opacity:0;
            transform-origin:center center;
            will-change: transform, opacity, background-position;
        }

        /* optional dark overlay on top of image for readability (per scene) */
        .dark-overlay {
            position:absolute; inset:0; background:rgba(0,0,0,0.32); opacity:0; pointer-events:none;
        }

        .text-container {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            /* Optional: subtle text stroke to improve crispness */
            /* -webkit-text-stroke: 0.5px rgba(0,0,0,0.1); */
        }

        /* text (keeps original styling) */
        .text-container {
            position:absolute;
            z-index: 60;
            font-weight:700;
            font-size: clamp(2rem, 5vw, 4rem);
            text-align:center;
            color:white;
            text-shadow: 0 4px 15px rgba(0,0,0,0.7);
            opacity:0;
            pointer-events:none;
            transform-origin:center center;
            will-change: transform, opacity;
        }
        .text-container .char { display:inline-block; }

        /* subtitle style */
        .subtitle {
            position:absolute;
            z-index: 60;
            bottom:8%;
            left:50%;
            transform: translateX(-50%);
            font-size: clamp(1rem, 2vw, 1.4rem);
            background: rgba(0,0,0,0.45);
            padding: .35rem .8rem;
            border-radius: .35rem;
            opacity:0;
            text-shadow: 0 2px 6px rgba(0,0,0,0.8);
            pointer-events:none;
            white-space: nowrap;
        }

        /* cinematic overlays */
        .film-grain {
            position:fixed; inset:0; z-index:90;
            pointer-events:none;
            background-image: url('https://www.transparenttextures.com/patterns/noise.png');
            opacity: 0.12;
        }
        .vignette {
            position:fixed; inset:0; z-index:89;
            pointer-events:none;
            background: radial-gradient(circle, rgba(0,0,0,0) 65%, rgba(0,0,0,0.6) 100%);
        }

        /* fade-to-black overlay used between scenes */
        #fade-overlay { position:fixed; inset:0; background:#000; z-index:95; pointer-events:none; opacity:0; }

        /* Initial loading overlay */
        #loading-overlay {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; opacity: 1; transition: opacity 0.5s ease-out;
        }

        /* scroll indicator */
        #scroll-indicator { position:absolute; bottom:22px; left:50%; transform:translateX(-50%); z-index:80; cursor:pointer; opacity:.95; }
        #scroll-indicator svg { width:36px; height:36px; animation: bounce 1.4s infinite; color:#fff; }
        @keyframes bounce { 0%,100%{ transform: translateY(0) } 50%{ transform: translateY(-8px) } }

        /* CTA styles preserved from original refactor */
        #cta-section {
            position:relative;
            width:100%;
            height:100vh;
            display:flex;
            flex-direction:column;
            justify-content:center;
            align-items:center;
            background: linear-gradient(135deg, #0F0F23, #1A1A2E, #16213E);
            z-index:10;
        }
        #cta-button { padding:1rem 2rem; border-radius:40px; font-weight:700; background:var(--accent); color:#000; text-decoration:none; }
        /* confetti canvas placed on top of CTA */
        #confetti-canvas { position:absolute; inset:0; z-index:9999; pointer-events:none; }
    </style>
</head>
<body>

    <!-- Initial Loading Overlay -->
    <div id="loading-overlay">Loading Hibo...</div>

    <!-- cinematic overlays -->
    <div class="film-grain"></div>
    <div class="vignette"></div>
    <div id="fade-overlay"></div>

    <!-- pinned storytelling container -->
    <div id="pin-container">
        <div id="scroll-indicator" title="Scroll">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 9l-7 7-7-7"/></svg>
        </div>
        <!-- layers and text will be injected here by script -->
    </div>

    <!-- CTA (final section) -->
    <section id="cta-section">
        <h2 style="font-size:clamp(2.5rem,6vw,5rem); margin-bottom:1rem; text-align:center; font-weight:700;">Start Your Journey</h2>
        <p style="max-width:680px; text-align:center; margin-bottom:1.5rem;">Transform your life through the power of small, consistent habits. Every expert was once a beginner.</p>
        <a id="cta-button" href="#">Begin Your Transformation ðŸš€</a>
        <canvas id="confetti-canvas"></canvas>
    </section>

    <!-- GSAP & ScrollTrigger -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <!-- confetti lib -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <script>
        gsap.registerPlugin(ScrollTrigger);

        // Tone.js setup
        let audioContextReady = false;
        let scenePlayer;

        // Function to initialize Tone.js on user interaction
        function initializeAudio() {
            if (audioContextReady) return;
            Tone.start().then(() => {
                scenePlayer = new Tone.Player().toDestination();
                scenePlayer.volume.value = -10; // Adjust overall volume
                audioContextReady = true;
                console.log("AudioContext ready!");
            }).catch(e => console.error("Tone.js initialization failed:", e));
        }

        // Play a simple sound (e.g., a short burst of noise for transition)
        function playSound(type = "default") {
            if (!audioContextReady) {
                console.warn("AudioContext not ready, cannot play sound.");
                return;
            }
            if (type === "reveal") {
                // A short, low-frequency tone or noise burst
                const synth = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.1 }
                }).toDestination();
                synth.triggerAttackRelease("C2", "0.3"); // Play a short burst of noise
            }
            // You can add more sound types here
        }

        // Attach audio initialization to first interaction (e.g., scroll, click)
        document.addEventListener('scroll', initializeAudio, { once: true });
        document.addEventListener('click', initializeAudio, { once: true });

        ////////////////////////////////
        // === EFFECT LIBRARIES ===
        // Separate dictionaries: textEffects and imageEffects
        ////////////////////////////////
        const textEffects = {
            // char-by-char slide up (original style)
            slideUp: (chars, container, options = {}) => {
                return gsap.from(chars, { y: options.y || 60, opacity: 0, stagger: options.stagger || 0.03, ease: options.ease || 'power2.out' });
            },

            // scale in each char
            scaleIn: (chars, container, options = {}) => {
                return gsap.from(chars, { scale: options.scale || 0.5, opacity: 0, stagger: options.stagger || 0.04, ease: options.ease || 'back.out(1.7)' });
            },

            // simple fade-in
            fadeIn: (chars, container, options = {}) => {
                return gsap.from(chars, { opacity: 0, stagger: options.stagger || 0.05, ease: options.ease || 'power1.inOut' });
            },

            // subtitle-style container animation (not char-by-char)
            subtitle: (chars, container, options = {}) => {
                return gsap.fromTo(container, { y: options.y || 20, opacity: 0 }, { y:0, opacity:1, duration: options.duration || 0.8, ease: options.ease || 'power2.out' });
            },

            // the "triple bounce" style for text (sharp jumps) â€” keeps original centering
            tripleBounceText: (chars, container, options = {}) => {
                const duration = options.duration || 1.5; // Made duration more reasonable
                gsap.set(container, { xPercent: -50, yPercent: -50, top: "50%", left: "50%" });
                const tl = gsap.timeline();
                tl.set(container, { opacity: 1 }, 0); // Ensure visible
                tl.to(container, { scale: 1.5, duration: duration / 3, ease: 'power2.inOut' })
                  .to(container, { scale: 2.2, duration: duration / 3, ease: 'power2.inOut' })
                  .to(container, { scale: 3.0, duration: duration / 3, ease: 'power2.inOut' });
                return tl;
            }
        };

        const imageEffects = {
            // fade image in
            fadeIn: (layer, options = {}) => {
                return gsap.fromTo(layer, { opacity: 0 }, { opacity: 1, duration: options.duration || 1, ease: options.ease || 'power1.out' });
            },

            // ken burns style gentle zoom (opt-in)
            kenBurns: (layer, options = {}) => {
                // Initial scale can be slightly higher than 1 to ensure full coverage
                gsap.set(layer, { scale: options.initialScale || 1.05, xPercent: options.initialXPercent || 0, yPercent: options.initialYPercent || 0 });
                return gsap.to(layer, { scale: options.toScale || 1.1, xPercent: options.xPercent || -5, yPercent: options.yPercent || 0, duration: options.duration || 6, ease: options.ease || 'power1.inOut' });
            },

            // triple jump effect for images (opt-in)
            tripleJumpImage: (layer, options = {}) => {
                const duration = options.duration || 1.5; // Made duration more reasonable
                const tl = gsap.timeline();
                tl.set(layer, { scale: 1 }, 0); // Ensure initial scale is 1
                tl.to(layer, { scale: 1.1, duration: duration / 3, ease: 'power2.inOut' })
                  .to(layer, { scale: 1.25, duration: duration / 3, ease: 'power2.inOut' })
                  .to(layer, { scale: 1.4, duration: duration / 3, ease: 'power2.inOut' });
                return tl;
            },

            // small pan left-to-right (background-position)
            slowPan: (layer, options = {}) => {
                const start = options.start || '45%';
                const end = options.end || '55%';
                gsap.set(layer, { backgroundPositionX: start });
                return gsap.to(layer, { backgroundPositionX: end, duration: options.duration || 6, ease: options.ease || 'none' });
            },

            // subtle parallax effect
            parallax: (layer, options = {}, sceneDuration) => {
                // This will apply a small Y movement during the scene's active scroll area
                // We will link this to the ScrollTrigger created for each scene
                return gsap.to(layer, {
                    yPercent: options.yEnd || 10,
                    ease: "none",
                    duration: sceneDuration, // Match scene duration
                    scrollTrigger: {
                        trigger: layer.parentElement, // Pin container is the trigger
                        start: `top top`, // Start of the current scene segment
                        end: `+=${sceneDuration * 1000}`, // End of the current scene segment
                        scrub: true,
                        // Using onUpdate to apply to individual layer's ScrollTrigger
                        // and connect to master timeline's scroll position
                        onUpdate: self => {
                            const progress = self.progress;
                            gsap.set(layer, { yPercent: gsap.utils.mapRange(0, 1, options.yStart || -10, options.yEnd || 10, progress) });
                        }
                    }
                });
            }
        };

        ////////////////////////////////
        // === STORY CONFIG ===
        // Each scene: image, text, subtitle (optional), and arrays of effect names
        ////////////////////////////////
        const storyConfig = {
            // Define a base duration for each scene, in seconds.
            // This dictates how long each scene will "hold" before fading to the next.
            // This is a crucial value for the ScrollTrigger's 'end' calculation.
            sceneBaseDuration: 3, // seconds per scene

            scenes: [
                {
                    text: "This is Hibo.",
                    subtitle: "The beginning of something great",
                    image: "https://images.unsplash.com/photo-1540553016722-983e48a2cd10?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "slideUp" }],
                    imageEffects: [{ name: "fadeIn" }, { name: "parallax", options: { yStart: -5, yEnd: 5 } }],
                    overlayOpacity: 0.30,
                    position: { top: "50%", left: "50%" },
                    sound: "reveal"
                },
                {
                    text: "A burst of motivation.",
                    subtitle: "Energy like never before",
                    image: "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "scaleIn" }],
                    imageEffects: [{ name: "fadeIn" }, { name: "kenBurns", options: { toScale: 1.08, xPercent: -5 } }],
                    overlayOpacity: 0.28,
                    position: { top: "20%", left: "50%" },
                    sound: "reveal"
                },
                {
                    text: "He worked harder and harder.",
                    subtitle: "Day after day",
                    image: "https://images.unsplash.com/photo-1534438327276-14e5300c3a48?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "fadeIn" }],
                    imageEffects: [{ name: "fadeIn" }, { name: "parallax", options: { yStart: -8, yEnd: 8 } }],
                    overlayOpacity: 0.40,
                    position: { top: "80%", left: "50%" },
                    sound: "reveal"
                },
                // intense / "again" scene â€” keeps the triple-bounce for text, image triple jump only if explicitly included
                {
                    text: "Again",
                    subtitle: "Relentless effort",
                    image: "https://images.unsplash.com/photo-1568602471122-7832951cc4c5?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "tripleBounceText", options: { duration: 1.0 } }],
                    imageEffects: [{ name: "tripleJumpImage", options: { duration: 1.0 } }], // opt-in triple image jump to match text intensity
                    overlayOpacity: 0.45,
                    position: { top: "50%", left: "50%" },
                    sound: "reveal"
                },
                {
                    text: "He found the secret.",
                    subtitle: "Persistence",
                    image: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "scaleIn" }],
                    imageEffects: [{ name: "fadeIn" }, { name: "slowPan" }],
                    overlayOpacity: 0.28,
                    position: { top: "30%", left: "80%" },
                    sound: "reveal"
                },
                {
                    text: "Start your journey.",
                    subtitle: "Yours begins now",
                    image: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1920&h=1080&fit=crop",
                    textEffects: [{ name: "slideUp" }],
                    imageEffects: [{ name: "fadeIn" }, { name: "parallax", options: { yStart: -7, yEnd: 7 } }],
                    overlayOpacity: 0.30,
                    position: { top: "60%", left: "25%" },
                    sound: "reveal"
                }
            ]
        };

        ////////////////////////////////
        // === BUILD DOM ===
        // We keep the original DOM structure: layers + textContainers rendered into #pin-container
        ////////////////////////////////
        const pinContainer = document.getElementById('pin-container');
        const fadeOverlay = document.getElementById('fade-overlay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const layers = [];
        const overlays = [];
        const textContainers = [];
        const subtitleContainers = [];

        storyConfig.scenes.forEach((scene, i) => {
            // layer
            const layer = document.createElement('div');
            layer.className = 'layer';
            layer.style.backgroundImage = `url('${scene.image}')`;
            layer.style.backgroundPosition = 'center center'; // Ensure initial center
            pinContainer.appendChild(layer);
            layers.push(layer);

            // overlay (darkening layer for readability)
            const overlay = document.createElement('div');
            overlay.className = 'dark-overlay';
            overlay.style.opacity = 0; // controlled by timeline
            pinContainer.appendChild(overlay);
            overlays.push(overlay);

            // text container (split into chars like original)
            const textWrap = document.createElement('div');
            textWrap.className = 'text-container';
            // position
            textWrap.style.top = (scene.position && scene.position.top) || "50%";
            textWrap.style.left = (scene.position && scene.position.left) || "50%";
            textWrap.style.transform = "translate(-50%, -50%)";
            // char split
            textWrap.innerHTML = scene.text.split("").map(c => `<span class="char">${c === " " ? "&nbsp;" : c}</span>`).join("");
            pinContainer.appendChild(textWrap);
            textContainers.push(textWrap);

            // subtitle
            const subtitle = document.createElement('div');
            subtitle.className = 'subtitle';
            subtitle.textContent = scene.subtitle || "";
            pinContainer.appendChild(subtitle);
            subtitleContainers.push(subtitle);
        });

        ////////////////////////////////
        // === MASTER TIMELINE ===
        ////////////////////////////////
        // Total scroll length for pinned section
        const totalScrollLength = storyConfig.scenes.length * (storyConfig.sceneBaseDuration * 1000); // in pixels
        const masterTl = gsap.timeline({
            scrollTrigger: {
                trigger: pinContainer,
                pin: true,
                scrub: 1, // Smoothly scrubs animations with scroll
                end: `+=${totalScrollLength}` // End based on total scene duration
            }
        });

        // Helper to apply text effects by name (returns tween or timeline)
        function applyTextEffectByName(effectObj, chars, container) {
            const { name, options = {} } = effectObj;
            if (!name) return null;
            const fn = textEffects[name];
            if (!fn) { console.warn("Missing text effect:", name); return null; }
            return fn(chars, container, options); // Pass options directly
        }

        // Helper to apply image effects by name
        function applyImageEffectByName(effectObj, layer, sceneDuration) {
            const { name, options = {} } = effectObj;
            if (!name) return null;
            const fn = imageEffects[name];
            if (!fn) { console.warn("Missing image effect:", name); return null; }
            // Pass sceneDuration for effects that need it (like parallax)
            return fn(layer, options, sceneDuration);
        }

        // Build the sequence
        storyConfig.scenes.forEach((scene, index) => {
            const layer = layers[index];
            const overlay = overlays[index];
            const textWrap = textContainers[index];
            const subtitleEl = subtitleContainers[index];
            const chars = textWrap.querySelectorAll('.char');
            const sceneDuration = storyConfig.sceneBaseDuration; // Duration for this scene in seconds

            // Create a separate timeline for each scene. This gives us precise control
            // over the timing of elements within each scene, independent of the main scroll.
            const sceneTl = gsap.timeline();

            // 1) Fade to black before switching (cinematic cut)
            sceneTl.to(fadeOverlay, { opacity: 1, duration: 0.35 });

            // 2) Ensure layer visible & reset transforms
            sceneTl.set(layer, { opacity: 1, scale: 1, clearProps: "transform" });
            sceneTl.set(overlay, { opacity: scene.overlayOpacity || 0.32 });

            // 3) Reveal by fading overlay out. This runs at the same time as image effects.
            sceneTl.to(fadeOverlay, { opacity: 0, duration: 0.35 });

            // Play scene specific sound, if defined
            if (scene.sound && audioContextReady) {
                sceneTl.call(() => playSound(scene.sound), [], "<"); // '<' starts sound at same time as previous animation
            }

            // 4) Image effects (parallel). Apply them at the start of the scene.
            if (Array.isArray(scene.imageEffects)) {
                scene.imageEffects.forEach(effectObj => {
                    // For parallax, we tie its ScrollTrigger to the master timeline's progress
                    if (effectObj.name === "parallax") {
                        // Create a specific ScrollTrigger for parallax within this scene's segment
                        gsap.to(layer, {
                            yPercent: effectObj.options.yEnd || 10,
                            ease: "none",
                            scrollTrigger: {
                                trigger: pinContainer,
                                start: `top top+=${index * sceneDuration * 1000}`,
                                end: `top top+=${(index + 1) * sceneDuration * 1000}`,
                                scrub: true,
                                onUpdate: self => {
                                    const progress = self.progress;
                                    gsap.set(layer, {
                                        yPercent: gsap.utils.mapRange(0, 1, effectObj.options.yStart || -10, effectObj.options.yEnd || 10, progress)
                                    });
                                }
                            }
                        });
                    } else {
                        const imgAnim = applyImageEffectByName(effectObj, layer, sceneDuration);
                        if (imgAnim) sceneTl.add(imgAnim, "<"); // Run other image effects in parallel with the reveal
                    }
                });
            } else {
                // Default gentle scale if no specific effects are chosen
                sceneTl.to(layer, { scale: 1.02, duration: sceneDuration * 0.5, ease: 'power1.out' }, "<");
            }

            // 5) Text reveal: either char effects or container-level (subtitle).
            // We add text opacity first so the container becomes visible and effects behave correctly.
            sceneTl.to(textWrap, { opacity: 1, duration: 0.08 }, "<+0.1"); // Slightly after image reveal

            if (Array.isArray(scene.textEffects)) {
                scene.textEffects.forEach(effectObj => {
                    const txtAnim = applyTextEffectByName(effectObj, chars, textWrap);
                    if (txtAnim) sceneTl.add(txtAnim, "<"); // Start text effects shortly after text becomes visible
                });
            } else {
                // Fallback to simple fadeIn if no specific text effects are chosen
                sceneTl.add(textEffects.fadeIn({ name: "fadeIn" }, chars, textWrap), "<");
            }

            // Show subtitle (if any) slightly after main text
            if (subtitleEl && subtitleEl.textContent.trim()) {
                sceneTl.to(subtitleEl, { opacity: 1, duration: 0.45 }, "<+0.2");
            }

            // Hold for readability before fading out
            sceneTl.to({}, { duration: sceneDuration - (sceneTl.duration() - sceneTl.scrollTrigger?.start) }); // Adjust hold duration dynamically
            // This ensures the total scene duration aligns with sceneBaseDuration

            // Fade out layer/text/overlay before next scene
            if (index < storyConfig.scenes.length - 1) {
                sceneTl.to(subtitleEl, { opacity: 0, duration: 0.35 }, ">-0.5"); // Start fading subtitle out earlier
                sceneTl.to(textWrap, { opacity: 0, duration: 0.6 }, "<");
                sceneTl.to([layer, overlay], { opacity: 0, duration: 0.8 }, "<+0.1");
                sceneTl.set([layer, overlay, textWrap, subtitleEl], { clearProps: "transform,opacity" });
            }

            // Add the entire scene timeline to the master timeline
            masterTl.add(sceneTl);
        });

        // Ensure clear at end so CTA appears cleanly
        masterTl.to(fadeOverlay, { opacity: 0, duration: 0.2 });


        ////////////////////////////////
        // CTA timeline + confetti
        ////////////////////////////////
        const cta = document.getElementById('cta-section');
        const ctaTl = gsap.timeline({
            scrollTrigger: {
                trigger: cta,
                start: "top 80%", // When top of CTA enters viewport at 80% from top
                toggleActions: "play none none none"
            }
        });

        ctaTl.from(cta, { opacity: 0, scale: 0.95, duration: 0.9 });
        ctaTl.call(() => {
            if (!cta.dataset.confettiLaunched) {
                fireConfettiBurst(); // confetti live
                cta.dataset.confettiLaunched = "true";
            }
        }, null, ">-0.3"); // Overlap slightly with CTA animation

        // confetti (canvas-confetti)
        const confettiCanvas = document.getElementById('confetti-canvas');
        const myConfetti = confetti.create(confettiCanvas, { resize: true, usePhysics: true }); // Fixed 'hysics' to 'physics'

        function fireConfettiBurst() {
            const duration = 2 * 1000;
            const end = Date.now() + duration;
            (function frame() {
                myConfetti({
                    particleCount: 5,
                    angle: 60,
                    spread: 55,
                    origin: { x: 0.1, y: 0.2 }
                });
                myConfetti({
                    particleCount: 5,
                    angle: 120,
                    spread: 55,
                    origin: { x: 0.9, y: 0.2 }
                });
                if (Date.now() < end) requestAnimationFrame(frame);
            })();
        }

        ////////////////////////////////
        // Scroll indicator: hide after first scroll or click
        ////////////////////////////////
        const scrollIndicator = document.getElementById('scroll-indicator');
        function hideScrollIndicator() {
            gsap.to(scrollIndicator, { opacity: 0, y: 16, duration: 0.6, pointerEvents: 'none' });
            window.removeEventListener('scroll', onFirstScroll);
        }
        function onFirstScroll() { hideScrollIndicator(); }
        window.addEventListener('scroll', onFirstScroll, { once: true });
        scrollIndicator.addEventListener('click', () => {
            window.scrollBy({ top: window.innerHeight * 0.8, behavior: 'smooth' });
            hideScrollIndicator();
        });

        // Hide loading overlay once content is loaded
        window.onload = () => {
            gsap.to(loadingOverlay, { opacity: 0, duration: 0.5, onComplete: () => loadingOverlay.style.display = 'none' });
        };

        // expose for dev debugging
        window.__HIBO = { textEffects, imageEffects, storyConfig, masterTl };

    </script>
</body>
</html>
